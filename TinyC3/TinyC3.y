%{  
//Declaration of C++ header files
#include <iostream>              
#include <cstdlib>
#include <string>
#include <stdio.h>
#include <sstream>
#include "TinyC3_22CS10037_22CS10042_translator.h"

using namespace std;

extern string var_type;			// last encountered variable type
extern int yylex(); 			// Generated by Flex
void yyerror(string s);			// error recovery	

%}
//declaring data types to be included in yylval
%union {            		
	
	struct Expression* expr;		   //expression
	struct Statement* stat;		   //statement	
	struct Array* Arr;  		   	   //array type

	char unaryOp;	  		   //unary operator		
	char* char_value;		   //char value

	int instr_number;		   //instruction number used for backpatching
	int int_value;			   //integer value	
	int num_params;			   //number of parameters

	class symboltype* sym_type;	   //symbol type  
	class symbolEntry* sym_ptr;			   //symbol pointer
} 

//**** TOKEN DECLARATIONS ***//

%token <sym_ptr> IDENTIFIER

%token <int_value> INTEGER_CONSTANT
%token <char_value> FLOAT_CONSTANT CHARACTER_CONSTANT STR_LTR

%token LPAREN RPAREN
%token LSQRP RSQRP
%token LFPAREN RFPAREN

%token   D_PLUS   D_MINUS NOT
%token MUL DIV PER PLUS MINUS TILDA XOR
%token DOT DOTS COMMA QUES COLON SEMI_COL
%token   ARR_MINUS HASH

%token D_LST D_GRT AND OR
%token D_AND D_OR
%token LST GRT L_EQT G_EQT D_EQT N_EQT

%token EQT MUL_EQT DIV_EQT PER_EQT P_EQT M_EQT 
%token DL_EQT DG_EQT A_EQT X_EQT O_EQT

%token EXTERN STATIC VOID CHAR SHORT INT LONG FLOAT DOUBLE CONST RESTRICT VOLATILE INLINE SIZEOF TYPEDEF UNION STRUCT

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN 

%right "LOWER_THAN_ELSE" ELSE

//Auxillary non-terminals M and N used for backpatching
%type <instr_number> M 	//store the next instruction to allow control flow
%type <stat> N 			//store the nex instruction list to allow control flow

//EXPRESSIONS
%type <expr>
	expression
	expression_opt
	primary_expression 
	multiplicative_expression
	additive_expression
	shift_expression
	relational_expression
	equality_expression
	AND_expression
	exclusive_OR_expression
	inclusive_OR_expression
	logical_AND_expression
	logical_OR_expression
	conditional_expression
	assignment_expression
	expression_statement

//unary operator
%type <unaryOp> unary_operator

//number of parameters
%type <num_params> argument_expression_list argument_expression_list_opt

//n dimensional arrays
%type <Arr> 
	postfix_expression
	unary_expression
	cast_expression

//STATEMENTS
%type <stat>  
	statement
	compound_statement
	selection_statement
	iteration_statement
	labeled_statement 
	jump_statement
	block_item
	block_item_list
	block_item_list_opt

//SYMBOL TYPE
%type <sym_type> pointer

//SYMBOL
%type <sym_ptr> initializer
%type <sym_ptr> direct_declarator init_declarator declarator

%start translation_unit

%%

//******----- 1.EXPRESSIONS ---- ******//

primary_expression 
		:  IDENTIFIER 								//expression : identifier
		{     
			$$ = new Expression();            		//Creating new expression object 		
			$$->type = "not-boolean";				//stating type of identifier
			updateNextInstr();	 
			//storing the location of the Symbol table where the identifier is present
			$$->location = $1;						
			updateNextInstr();
		}
		| INTEGER_CONSTANT			//expression : integer constant	   			
		{    
			$$ = new Expression();	       		//Creating new expression object	
			updateNextInstr();
			string str = convertInt2String($1);    //converting integer constant to string  
			updateNextInstr();
			// Creating a temporary variable initialized with the string representation of an integer constant; storing the address in the symbol table where the temporary variable is located.
			$$->location = symboltable::gentemp(new symboltype("int"),str);      
			updateNextInstr();
			emit("=",$$->location->name,str);   // temp : string(integer constant)   
			updateNextInstr();
		}
		| FLOAT_CONSTANT				   //expression : floating point constant			
		{  
			$$ = new Expression();	       //Creating new expression object			
			updateNextInstr();
			// Creating a temporary variable initialized with the string representation of a float constant; storing the address in the symbol table where the temporary variable is located
			$$->location = symboltable::gentemp(new symboltype("float"),$1);
			updateNextInstr();
			emit("=",$$->location->name,string($1));  // temp : string(float constant)
			updateNextInstr();
		}
		| CHARACTER_CONSTANT    //expression : character constant           			
		{    
			$$ = new Expression();		//Creating new expression object			
			updateNextInstr();
			//creating a temporary variable with initial value as character ; storing the location of the symbol table where the temporary variable is present
			$$->location = symboltable::gentemp(new symboltype("char"),$1);
			updateNextInstr();
			emit("=",$$->location->name,string($1)); // temp : character constant
			updateNextInstr();
		}
		| STR_LTR  		//expression : string literal		  			
		{   
			$$ = new Expression();		//Creating new expression object			
			updateNextInstr();
			// Creating a temporary variable initialized with the base address of the string literal; storing the address in the symbol table where the temporary variable is located.
			$$->location = symboltable::gentemp(new symboltype("ptr"),$1);
			updateNextInstr();
			$$->location->type->arraytype=new symboltype("char");   
			updateNextInstr();
		}
		| LPAREN expression RPAREN   //expression : expression
		{   
			$$ = $2;			//equity of expression					
		}
		;

postfix_expression 
		: primary_expression 
		{
			$$ = new Array();            //creating a new Array object           
			updateNextInstr();
			$$->location = $$->Array;		//storing location of Array		
			updateNextInstr();
			$$->Array = $1->location;		//array pointing to the location of primary expression		 
			updateNextInstr();
			$$->type = $1->location->type;		//type(postfix expr) : type(primary expr)			
			updateNextInstr();
		}
		| postfix_expression LSQRP expression RSQRP
		{
			$$ = new Array();			//creating a new Array object			
			updateNextInstr();
			$$->type = $1->type->arraytype;		//type(postfix expr) : type(primary expr)			
			updateNextInstr();			
			$$->Array = $1->Array;		//array of postfix expr. pointing to array of primary expr.		   
			updateNextInstr();
			$$->location = symboltable::gentemp(new symboltype("int"));		//generating a temporary variable and storing its location
			updateNextInstr();
			$$->atype = "arr";			//typeOf(Array value) : array			
			updateNextInstr();
			if($1->atype == "arr")          //checking the case of multidimensional array        
			{
				symbolEntry* temp_var = symboltable::gentemp(new symboltype("int"));    //generated a new entry in the symbol table of type(int)
				updateNextInstr();
				int sz = computeSize($$->type);       	 // sz : sizeOf(postfix expression)		
				updateNextInstr();
				string str = convertInt2String(sz);  	// str : string(sz)		 
				updateNextInstr();
				//computing base address of variable for multidimensional array
				emit("*",temp_var->name,$3->location->name,str);
				updateNextInstr();	
				emit("+",$$->location->name,$1->location->name,temp_var->name);  
				updateNextInstr();
			}
			else        //one-dimensional array case              
			{                         
				int sz = computeSize($$->type);		 // sz : sizeOf(postfix expression)			
				updateNextInstr();
				string str = convertInt2String(sz);		// str : string(sz)		
				updateNextInstr();
				//computing base address of variable for single dimensional array
				emit("*",$$->location->name,$3->location->name,str);
				updateNextInstr();
			}
		}
		| postfix_expression LPAREN argument_expression_list_opt RPAREN	     //function defination with 0 or more parameters
		{     
			$$=new Array();				//creating a Array object			
			updateNextInstr();
			$$->Array=symboltable::gentemp($1->type);		//specifying return value of the function	
			updateNextInstr();
			string str=convertInt2String($3);		//str : string(count # of arguments)
			updateNextInstr();
			emit("call",$$->Array->name,$1->Array->name,str); //call func_name,str where str is # of arguments in func_name defination
			updateNextInstr();
		}
		| postfix_expression DOT IDENTIFIER      {     }		
		| postfix_expression   ARR_MINUS IDENTIFIER  {     }
		| postfix_expression   D_PLUS        //unary increment operator after a expression        
		{
			$$=new Array();			//creating a Array object						
			updateNextInstr();
			$$->Array=symboltable::gentemp($1->Array->type);   //generating temporary variable of type(postfix expression)          
			updateNextInstr();	
			emit("=",$$->Array->name,$1->Array->name);     //first copy instruction 
			updateNextInstr();
			emit("+",$1->Array->name,$1->Array->name,"1");    //then increment and store the new values
			updateNextInstr();    
		}
		| postfix_expression   D_MINUS		//unary decrement operator after a expression		
		{
			$$=new Array();			//creating a Array object						 
			updateNextInstr();
			$$->Array=symboltable::gentemp($1->Array->type);		//generating temporary variable of type(postfix expression)		  
			updateNextInstr();	
			emit("=",$$->Array->name,$1->Array->name);		//first copy instruction   
			updateNextInstr();
			emit("-",$1->Array->name,$1->Array->name,"1");    //then decrement and store the new values 
			updateNextInstr();    
		}
		| LPAREN type_name RPAREN LFPAREN initializer_list RFPAREN       {	    }
		| LPAREN type_name RPAREN LFPAREN initializer_list COMMA RFPAREN {		}
		;


argument_expression_list_opt 
	  	: argument_expression_list
	  	{
	  		$$ = $1;						//equating the expression structure
	  	}
	  	| %empty
	  	{
	  		$$ = 0;                         //initilising # of parameters = 0 in case function argument list is empty
	  	}
	  	;


argument_expression_list 
		: assignment_expression
		{    
			$$=1;                              //only fucntion argument
			updateNextInstr();
			emit("param",$1->location->name);  //emit parameter instruction
			updateNextInstr();
		}
	  	| argument_expression_list COMMA assignment_expression
	    {
			$$=$1+1;                           //increment # of function arguments
			updateNextInstr();
			emit("param",$3->location->name);  //emit parameter instruction
			updateNextInstr();
	    }
	  	;


unary_expression 
		: postfix_expression						
		{
			$$ = $1;    						//equality of unary and postfix expression
		}
		| D_PLUS unary_expression      //unary increment operator before an expression
		{
			emit("+",$2->Array->name,$2->Array->name,"1");  //incrementing value of expression value by 1
			updateNextInstr();
			$$=$2;										    //assigning the new value to the LHS expression
			updateNextInstr();   
		}
		| D_MINUS unary_expression		//unary decrement operator before an expression
		{
			emit("-",$2->Array->name,$2->Array->name,"1");  //decrementing value of expression value by 1
			updateNextInstr();
			$$=$2;											//assigning the new value to the LHS expression
			updateNextInstr();   
		}
		| unary_operator cast_expression           //unary operator before an expression            
		{      	
			$$=new Array();				//creating an Array object					  
			updateNextInstr();
			switch($1)				//checking the type of unary operator  
			{	  
				case '&':     //generating a temporary variable of pointer data type        
					$$->Array=symboltable::gentemp((new symboltype("ptr")));
					updateNextInstr();
					$$->Array->type->arraytype=$2->Array->type;     //assigning the data type of the value to be pointed to as the data type of cast expression 
					updateNextInstr();
					emit("=&",$$->Array->name,$2->Array->name);   //pointer reference instruction 
					updateNextInstr();
					break;

				case '*':           //unary expression stores the value of a pointer    
					$$->atype="ptr";
					updateNextInstr();
					$$->location=symboltable::gentemp($2->Array->type->arraytype);   //assigning value pointed to, by the cast expression pointer  
					updateNextInstr();
					$$->Array=$2->Array;							 
					updateNextInstr();
					emit("=*",$$->location->name,$2->Array->name);      //pointer value assigned instruction
					updateNextInstr();
					break;

				case '+':  
					$$=$2;		//unary plus sign does not matter		  
					break;
					                    
				case '-':			//unary minus	  
					$$->Array=symboltable::gentemp(new symboltype($2->Array->type->type));   //generating temporary varible for storing negative value of expression value 
					updateNextInstr();
					emit("MINUS",$$->Array->name,$2->Array->name);
					updateNextInstr();
					break;

				case '~':          //bitwise not           
					$$->Array=symboltable::gentemp(new symboltype($2->Array->type->type));      //generating temporary variable of the same base type to store the negation of expression value
					updateNextInstr();
					emit("~",$$->Array->name,$2->Array->name);
					updateNextInstr();
					break;

				case '!':	// logical not			  
					$$->Array=symboltable::gentemp(new symboltype($2->Array->type->type));
					  //generate temporary variable of the same base type and storing the negation of boolean value of the expression
					updateNextInstr();
					emit("!",$$->Array->name,$2->Array->name);
					updateNextInstr();
					break;
			}
		}
		| SIZEOF unary_expression 									{	}
		| SIZEOF LPAREN type_name RPAREN	{	}
		;


unary_operator
		: AND
		{
			$$ = '&';			//assigning operator		  
			updateNextInstr();
		}
		| MUL
		{
			$$ = '*';				//assigning operator	  
			updateNextInstr();
		}
		| PLUS
		{
			$$ = '+';					 //assigning operator 
			updateNextInstr();
		}
		| MINUS
		{
			$$ = '-';					//assigning operator  
			updateNextInstr();
		}
		| TILDA
		{
			$$ = '~';			//assigning operator		  
			updateNextInstr();
		}
		| NOT
		{
			$$ = '!';			//assigning operator		  
			updateNextInstr();
		}
		;


cast_expression 
		: unary_expression
		{
			$$ = $1;     		//equating the value of expressions		  
		}
		| LPAREN type_name RPAREN cast_expression
		{ 							//explicit type conversion of data	  
			$$=new Array();			//creating an Array object	  
			updateNextInstr();	
			$$->Array=convertType($4->Array,var_type);    //storing the new value of the cast expression obtained after performing the required conversion  
			updateNextInstr();
		}
		;


multiplicative_expression 
		: cast_expression 					   // Assigning value of cast expression
		{
			$$ = new Expression();             // Creating an Expression object	
			updateNextInstr();						    
			if($1->atype=="arr") 			   // Check if the cast expression is of type 'array'
			{
				$$->location = symboltable::gentemp($1->location->type);	  // Generate a temporary and store its Symbol table location
				updateNextInstr();
				emit("=[]",  $$->location->name,$1->Array->name, $1->location->name);       // Emit array access operation
				updateNextInstr();
			}
			else if($1->atype=="ptr")         // Check if the cast expression is of type 'pointer'
			{ 
				$$->location = $1->location;       // Assigning the location value of cast expression
				updateNextInstr();
			}
			else 							// For cases where cast expression is neither array nor pointer
			{
				$$->location = $1->Array;		// Assigning Array value
				updateNextInstr();
			}
		}
		| multiplicative_expression MUL cast_expression       // For multiplication operation
		{ 
			// Check compatibility of data types of both RHS expressions
			if(!compareSymbolType($1->location, $3->Array))  
			{    
				cout << " Mismatch of Data Type " << endl;	      // Print error for mismatch of data types
			}
			else 
			{
				$$ = new Expression();	
				updateNextInstr();
				// Generate a temporary to store the value after multiplication
				$$->location = symboltable::gentemp(new symboltype($1->location->type->type));
				updateNextInstr();
				emit("*",$$->location->name,$1->location->name, $3->Array->name); // Emit multiplication operation
				updateNextInstr();
			}
		}
		| multiplicative_expression DIV cast_expression         // For division operation
		{ 
			// Check compatibility of data types of both RHS expressions
			if(!compareSymbolType($1->location, $3->Array)) 
			{        
				cout<<"	Mismatch of Data Type "<< endl;	       // Print error for mismatch of data types
			}
			else 
			{
				$$ = new Expression();	
				updateNextInstr();
				// Generate a temporary to store the value after division
				$$->location = symboltable::gentemp(new symboltype($1->location->type->type));
				updateNextInstr();
				emit("/",$$->location->name,$1->location->name, $3->Array->name); // Emit division operation
				updateNextInstr();
			}
		}
		| multiplicative_expression PER cast_expression            // For modulus operation 
		{ 
			// Check compatibility of data types of both RHS expressions
			if(!compareSymbolType($1->location, $3->Array))  
			{       
				cout<<"	Mismatch of Data Type "<< endl;         	// Print error for mismatch of data types
			}
			else
			{
				$$ = new Expression();	
				updateNextInstr();
				// Generate a temporary to store the value after performing modulus
				$$->location = symboltable::gentemp(new symboltype($1->location->type->type));
				updateNextInstr();
				emit("%",$$->location->name,$1->location->name, $3->Array->name); // Emit modulus operation
				updateNextInstr();
			}
		}
		;


additive_expression 
		: multiplicative_expression // Direct assignment of multiplicative expression
		{ 
			$$ = $1;   					// Equating the two expressions
		}
		| additive_expression PLUS multiplicative_expression    // For addition operation
		{
			// Check compatibility of data types of both RHS expressions
			if(!compareSymbolType($1->location, $3->location))
			{
				cout <<" Mismatch of Data Type "<< endl;       // Print error for mismatch of data types
			}
			else    
			{
				$$ = new Expression();	
				updateNextInstr();
				// Generate a temporary to store the value after performing addition
				$$->location = symboltable::gentemp(new symboltype($1->location->type->type));
				updateNextInstr();
				emit("+",$$->location->name, $1->location->name, $3->location->name); // Emit addition operation
				updateNextInstr();
			}
		}
		| additive_expression MINUS multiplicative_expression      // For subtraction operation
		{
			// Check compatibility of data types of both RHS expressions
			if(!compareSymbolType($1->location, $3->location))
			{
				cout << " Mismatch of Data Type "<< endl;          // Print error for mismatch of data types
			}
			else 
			{
				$$ = new Expression();	
				updateNextInstr();
				// Generate a temporary to store the value after performing subtraction
				$$->location = symboltable::gentemp(new symboltype($1->location->type->type));
				updateNextInstr();
				emit("-",$$->location->name, $1->location->name, $3->location->name); // Emit subtraction operation
				updateNextInstr();
			}
		}
		;


shift_expression 
		: additive_expression // Direct assignment of additive expression
		{
			$$ = $1;  					// Equating the value of two expressions
		}
		| shift_expression D_LST additive_expression     // For bitwise left shift operation
		{ 
			// Ensure shifting left is to be done by a constant
			if(!($3->location->type->type == "int"))
			{
				cout << " Shifting cannot be done : Not an integer value "<< endl; 						// Print error 
			}
			else           
			{		
				$$ = new Expression();	
				updateNextInstr();
				// Generate a temporary to store the value after performing left shift
				$$->location = symboltable::gentemp(new symboltype("int"));
				updateNextInstr();
				emit("<<",$$->location->name, $1->location->name, $3->location->name); // Emit left shift operation
				updateNextInstr();
			}
		}
		| shift_expression D_GRT additive_expression      // For bitwise right shift operation 
		{ 
			// Ensure shifting right is to be done by a constant
			if(!($3->location->type->type == "int"))
			{
				cout << " Shifting cannot be done : Not an integer value "<< endl; 						// Print error 
			}
			else            
			{		
				$$ = new Expression();	
				updateNextInstr();
				// Generate a temporary to store the value after performing right shift
				$$->location = symboltable::gentemp(new symboltype("int"));
				updateNextInstr();
				emit(">>", $$->location->name, $1->location->name, $3->location->name); // Emit right shift operation
				updateNextInstr();
			}
		}
		;


relational_expression 
		: shift_expression
		{ 
			$$ = $1;				 // Assign the result of shift_expression to relational_expression
		}
		| relational_expression LST shift_expression         
		{
			// Check if the types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl; // Print error message for type mismatch
			}
			else 
			{     								
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr();     // Update the instruction counter
				$$->type = "bool";     // Set the type of the expression to boolean
				updateNextInstr();		
				$$->trueList = makelist(nextinstr()); // Create the true list for the boolean expression
				updateNextInstr();
				$$->falseList = makelist(nextinstr()+1); // Create the false list for the boolean expression
				updateNextInstr();
				emit("<","",$1->location->name, $3->location->name); // Emit the less than operation
				updateNextInstr();
				emit("goto", ""); // Emit the goto statement
				updateNextInstr();
			}
		} 
		| relational_expression GRT shift_expression          
		{
			// Check if the types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl; // Print error message for type mismatch
			}
			else 
			{							
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr();     // Update the instruction counter
				$$->type = "bool";     // Set the type of the expression to boolean
				updateNextInstr();		
				$$->trueList = makelist(nextinstr()); // Create the true list for the boolean expression
				updateNextInstr();
				$$->falseList = makelist(nextinstr()+1); // Create the false list for the boolean expression
				updateNextInstr();
				emit(">","",$1->location->name, $3->location->name); // Emit the greater than operation
				updateNextInstr();
				emit("goto", ""); // Emit the goto statement
				updateNextInstr();
			}
		}
		| relational_expression L_EQT shift_expression           
		{
			// Check if the types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl; // Print error message for type mismatch
			}
			else 
			{    							
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr();     // Update the instruction counter
				$$->type = "bool";     // Set the type of the expression to boolean
				updateNextInstr();		
				$$->trueList = makelist(nextinstr()); // Create the true list for the boolean expression
				updateNextInstr();
				$$->falseList = makelist(nextinstr()+1); // Create the false list for the boolean expression
				updateNextInstr();
				emit("<=","",$1->location->name, $3->location->name); // Emit the less than or equal to operation
				updateNextInstr();
				emit("goto", ""); // Emit the goto statement
				updateNextInstr();
			}
		}
		| relational_expression G_EQT shift_expression          
		{
			// Check if the types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl; // Print error message for type mismatch
			}
			else 
			{    							
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr();     // Update the instruction counter
				$$->type = "bool";     // Set the type of the expression to boolean
				updateNextInstr();		
				$$->trueList = makelist(nextinstr()); // Create the true list for the boolean expression
				updateNextInstr();
				$$->falseList = makelist(nextinstr()+1); // Create the false list for the boolean expression
				updateNextInstr();
				emit(">=","",$1->location->name, $3->location->name); // Emit the greater than or equal to operation
				updateNextInstr();
				emit("goto", ""); // Emit the goto statement
				updateNextInstr();
			}
		}
		;


equality_expression 
		: relational_expression
		{
			$$ = $1; // Assign the result of relational_expression to equality_expression
		}
		| equality_expression D_EQT relational_expression         
		{
			// Check if the types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location)) 
			{
				cout << " Mismatch of Data Type "<< endl; // Print error message for type mismatch
			}
			else 
			{
				convertBool2Int($1); // Convert the first expression to integer
				updateNextInstr();	
				convertBool2Int($3); // Convert the second expression to integer
				updateNextInstr();
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr();
				$$->type = "bool"; // Set the type of the expression to boolean
				updateNextInstr();
				$$->trueList = makelist(nextinstr()); // Create the true list for the boolean expression
				$$->falseList = makelist(nextinstr()+1); // Create the false list for the boolean expression
				updateNextInstr();
				emit("==", "", $1->location->name, $3->location->name); // Emit the equality operation
				updateNextInstr();
				emit("goto", ""); // Emit the goto statement
				updateNextInstr();
			}
		}
		| equality_expression N_EQT relational_expression
		{
			// Check if the types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location))  
			{
				cout <<" Mismatch of Data Type "<< endl; // Print error message for type mismatch
			}
			else 
			{
				convertBool2Int($1); // Convert the first expression to integer
				updateNextInstr();	
				convertBool2Int($3); // Convert the second expression to integer
				updateNextInstr();
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr();
				$$->type = "bool"; // Set the type of the expression to boolean
				updateNextInstr();
				$$->trueList = makelist(nextinstr()); // Create the true list for the boolean expression
				$$->falseList = makelist(nextinstr()+1); // Create the false list for the boolean expression
				updateNextInstr();
				emit("!=", "", $1->location->name, $3->location->name); // Emit the not equal operation
				updateNextInstr();
				emit("goto", ""); // Emit the goto statement
				updateNextInstr();
			}
		}
		;


AND_expression 
		: equality_expression
		{
			$$ = $1; // Assign the result of equality_expression to AND_expression
		}
		| AND_expression AND equality_expression
		{
			// Check if the types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location))
			{	
				cout << " Mismatch of Data Type "<< endl; // Print error message for type mismatch
			}
			else 
			{            
				convertBool2Int($1); // Convert the first expression to integer
				updateNextInstr();
				convertBool2Int($3); // Convert the second expression to integer
				updateNextInstr();
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr();
				$$->type = "not-boolean"; // Set the type of the expression to not-boolean
				updateNextInstr();
				$$->location = symboltable::gentemp(new symboltype("int")); // Generate a temporary symbol for the location
				updateNextInstr();
				emit("&", $$->location->name, $1->location->name, $3->location->name); // Emit the AND operation
				updateNextInstr();
			}
		}
		;


exclusive_OR_expression 
		: AND_expression
		{
			$$ = $1;    				// Assign the value of AND_expression to the result
		}
		| exclusive_OR_expression XOR AND_expression
		{
			// Check if the data types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location))    
			{
				cout << "Mismatch of Data Type "<< endl; // Print error for mismatch of data types
			}
			else 
			{
				// Convert boolean values to integers for processing
				convertBool2Int($1);                  
				updateNextInstr(); // Move to the next instruction
				convertBool2Int($3);                  
				updateNextInstr(); // Move to the next instruction
				
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr(); // Move to the next instruction
				$$->type = "not-boolean"; // Set the type to not-boolean (result type)
				updateNextInstr(); // Move to the next instruction
				
				// Generate a temporary variable to hold the result
				$$->location = symboltable::gentemp(new symboltype("int"));
				updateNextInstr(); // Move to the next instruction
				
				// Emit the operation for XOR with the temporary variable's location and operand locations
				emit("^", $$->location->name, $1->location->name, $3->location->name); 
				updateNextInstr(); // Move to the next instruction
			}
		}
		;

inclusive_OR_expression 
		: exclusive_OR_expression
		{
			$$ = $1;    				// Assign the value of exclusive_OR_expression to the result
		}
		| inclusive_OR_expression OR exclusive_OR_expression
		{
			// Check if the data types of both expressions are compatible
			if(!compareSymbolType($1->location, $3->location))
			{
				cout << "Mismatch of Data Type "<< endl; // Print error for mismatch of data types
			}
			else 
			{
				// Convert boolean values to integers for processing
				convertBool2Int($1);	              
				updateNextInstr(); // Move to the next instruction
				convertBool2Int($3);                 
				updateNextInstr(); // Move to the next instruction
				
				$$ = new Expression(); // Create a new Expression object
				updateNextInstr(); // Move to the next instruction
				$$->type = "not-boolean"; // Set the type to not-boolean (result type)
				updateNextInstr(); // Move to the next instruction
				
				// Generate a temporary variable to hold the result
				$$->location = symboltable::gentemp(new symboltype("int"));
				updateNextInstr(); // Move to the next instruction
				
				// Emit the operation for inclusive OR with the temporary variable's location and operand locations
				emit("|", $$->location->name, $1->location->name, $3->location->name);
				updateNextInstr(); // Move to the next instruction
			} 
		}
 		;

logical_AND_expression 
		: inclusive_OR_expression
		{
			$$ = $1;        				// Assign the value of inclusive_OR_expression to the result
		}
		| logical_AND_expression N D_AND M inclusive_OR_expression
		{
			// Convert the last inclusive OR expression to boolean
			convertInt2Bool($5);    
			updateNextInstr(); // Move to the next instruction
			
			// Backpatch the next instruction for the logical AND operation
			backpatch($2->nextList, nextinstr());
			updateNextInstr(); // Move to the next instruction
			
			// Convert the current logical AND expression to boolean
			convertInt2Bool($1);  
			updateNextInstr(); // Move to the next instruction
			
			$$ = new Expression(); // Create a new Expression object
			updateNextInstr(); // Move to the next instruction
			$$->type = "bool"; // Set the type to boolean
			updateNextInstr(); // Move to the next instruction
			
			// Backpatch the true list of the first expression
			backpatch($1->trueList, $4);       
			updateNextInstr(); // Move to the next instruction
			
			// Set the trueList to that of the last inclusive OR expression
			$$->trueList = $5->trueList;      
			updateNextInstr(); // Move to the next instruction
			
			// Merge the false lists of both expressions
			$$->falseList = merge($1->falseList, $5->falseList);   
			updateNextInstr(); // Move to the next instruction
		}
		;


logical_OR_expression 
		: logical_AND_expression
		{
			$$ = $1;         				// Equating the value of the logical AND expression
		}
		| logical_OR_expression N D_OR M logical_AND_expression
		{
			convertInt2Bool($5);    // Convert the right-hand side logical AND expression to boolean
			backpatch($2->nextList, nextinstr());   // Backpatch the next instruction for the OR operator
			convertInt2Bool($1);    // Convert the left-hand side logical OR expression to boolean
			$$ = new Expression();   // Create a new Expression object for the result
			$$->type = "bool";       // Set the type of the expression to boolean
			backpatch($1->falseList, $4); // If the left expression is false, jump to instruction $4
			$$->trueList = merge($1->trueList, $5->trueList); // Merge true lists from both expressions
			$$->falseList = $5->falseList; // Set the false list for the result to the right expression's false list
		}
		;


conditional_expression 
		: logical_OR_expression
		{
			$$ = $1;           				// Equating the value of the logical OR expression
		}
		| logical_OR_expression N QUES M expression N COLON M conditional_expression
		{
			$$->location = symboltable::gentemp($5->location->type); // Generate a temporary location for the value
			$$->location->update($5->location->type); // Update the temporary location's type
			emit("=", $$->location->name, $9->location->name); // Emit instruction to copy the value from the expression
			list<int> l = makelist(nextinstr());       // Create a list for the next instruction after the first branch
			emit("goto", "");                          // Emit a goto to prevent fallthrough to the next branch
			backpatch($6->nextList, nextinstr());     // Backpatch to go to the next instruction after the conditional check
			emit("=", $$->location->name, $5->location->name); // Assign the value from the left expression to the temporary
			list<int> m = makelist(nextinstr());      // Create another list for the next instruction after the assignment
			l = merge(l, m);						  // Merge the two lists of instructions to ensure correct flow
			emit("goto", "");						  // Emit a goto to prevent fallthrough
			backpatch($2->nextList, nextinstr());     // Backpatch to handle the next instruction for the condition
			convertInt2Bool($1);                     // Convert the logical OR expression to boolean for evaluation
			backpatch($1->trueList, $4);           // If the logical OR expression is true, go to the value expression
			backpatch($1->falseList, $8);          // If false, go to the conditional expression
			backpatch(l, nextinstr());              // Backpatch the merged instruction list for flow control
		}
		;


assignment_expression 
		: conditional_expression
		{
			$$ = $1;       //equating the value of 2 expressions       	  
		}
		| unary_expression assignment_operator assignment_expression
		{
			if($1->atype=="arr")         //if type is arr, simply check if we need to convert and emit  
			{
				$3->location = convertType($3->location, $1->type->type);
				updateNextInstr();
				emit("[]=", $1->Array->name, $1->location->name, $3->location->name);		
				updateNextInstr();
			}
			else if($1->atype=="ptr")       //if type is ptr, simply emit 
			{
				emit("*=", $1->Array->name, $3->location->name);		
				updateNextInstr();
			}
			else           //otherwise copy the value                  
			{
				$3->location = convertType($3->location, $1->Array->type->type);
				emit("=", $1->Array->name, $3->location->name);
				updateNextInstr();
			}
			
			$$ = $3;
		}
		;


assignment_operator
		: EQT    			{	}
		| MUL_EQT			{	}
		| DIV_EQT			{	}
		| PER_EQT			{	}
		| P_EQT			{	}
		| M_EQT			{	}
		| DL_EQT	{	}
		| DG_EQT	{	}
		| A_EQT	{	}
		| X_EQT			{	}
		| O_EQT		{	}
		;


expression 
		: assignment_expression
		{
			$$ = $1;            	  
		}
		| expression COMMA assignment_expression 	{	}
		;


constant_expression 
		: conditional_expression   {	}
		;


//*****----- 2.DECLARATIONS -----****//

declaration 
		: declaration_specifiers init_declarator_list_opt SEMI_COL	{	}
		;


init_declarator_list_opt 
		: init_declarator_list 	{	}
		| %empty 				{	}
		;


declaration_specifiers 
		: storage_class_specifier declaration_specifiers_opt	{	}
		| type_specifier declaration_specifiers_opt				{	}
		| type_qualifier declaration_specifiers_opt				{	}
		| function_specifier declaration_specifiers_opt			{	}
		;


declaration_specifiers_opt 
		: declaration_specifiers {	}
		| %empty				 {	}	
		;


init_declarator_list 
		: init_declarator 								{	}
		| init_declarator_list COMMA init_declarator 	{	}
		;


init_declarator 
		: declarator  
		{
			$$=$1;	         //equating the value of 2 expressions 	  
		}
		| declarator EQT initializer
		{
			if($3->val!="") 
				$1->val=$3->val;    //initialising declarator with value of initializer   
			emit("=", $1->name, $3->name);      //copy value instruction 
			updateNextInstr();
		}
		;

storage_class_specifier 
		: EXTERN 	{	}
		| STATIC	{	}
		;

type_specifier       
		: VOID   {  var_type = "void";  }
		| CHAR   {  var_type = "char";  }
		| SHORT  {   					}
		| INT 	 {  var_type = "int";   }
		| LONG   {   					}
		| FLOAT  {  var_type = "float"; }
		| DOUBLE {   					}
		;

specifier_qualifier_list 
		: type_specifier specifier_qualifier_list_opt	{	}
		| type_qualifier specifier_qualifier_list_opt	{	}
		;

specifier_qualifier_list_opt 
		: specifier_qualifier_list  {	}
		| %empty					{	}
		;

type_qualifier 
		: CONST 	{	}
		| RESTRICT	{	}
		| VOLATILE	{	}
		;

function_specifier 
		: INLINE 	{	}
		;

declarator 
		: pointer direct_declarator
		{
			symboltype *t = $1;
			updateNextInstr();
			// For multidimensional arrays, traverse until reaching the base type
			while(t->arraytype != NULL) 
				t = t->arraytype;          
			updateNextInstr();
			t->arraytype = $2->type;              // Set the base type
			updateNextInstr();
			$$ = $2->update($1);                // Update the symbol
			updateNextInstr();
		}
		| direct_declarator		{	}
		;


direct_declarator 
		: IDENTIFIER         
		{
			$$ = $1->update(new symboltype(var_type));   // Add a new variable with var_type
			updateNextInstr();
			currSymbolPtr = $$;
			updateNextInstr();
		}
		| LPAREN declarator RPAREN  
		{ 
			$$ = $2; 						// Set the value of declarators
		}
		| direct_declarator LSQRP type_qualifier_list assignment_expression RSQRP		{	}
		| direct_declarator LSQRP assignment_expression RSQRP		
		{
			symboltype *t = $1->type;      // Create a symbol based on the declarator type
			updateNextInstr();
			symboltype *prev = NULL;
			updateNextInstr();
			while(t->type == "arr") 
			{
				prev = t;	
				t = t->arraytype;            // Recursively navigate to the base type
				updateNextInstr();
			}
			if(prev == NULL) 
			{
				int temp = atoi($3->location->val.c_str());   // Get the initial value
				updateNextInstr();
				symboltype* s = new symboltype("arr", $1->type, temp);   // Create an array symbol with the initial size
				updateNextInstr();
				$$ = $1->update(s);         // Update the symbol table with the array type
				updateNextInstr();
			}
			else 
			{
				prev->arraytype =  new symboltype("arr", t, atoi($3->location->val.c_str()));
				updateNextInstr();
				$$ = $1->update($1->type);
				updateNextInstr();
			}
		}
		| direct_declarator LSQRP type_qualifier_list RSQRP		{	}
		| direct_declarator LSQRP RSQRP		
		{
			symboltype *t = $1->type;      // Create a symbol based on the declarator type
			updateNextInstr();
			symboltype *prev = NULL;
			updateNextInstr();
			while(t->type == "arr") 
			{
				prev = t;	
				t = t->arraytype;            // Recursively navigate to the base type
				updateNextInstr();
			}
			if(prev == NULL) 
			{
				symboltype* s = new symboltype("arr", $1->type, 0);   // Create an array with size 0 if no initial value is provided
				updateNextInstr();
				$$ = $1->update(s);
				updateNextInstr();	
			}
			else 
			{
				prev->arraytype =  new symboltype("arr", t, 0);
				updateNextInstr();
				$$ = $1->update($1->type);
				updateNextInstr();
			}
		}
		| direct_declarator LSQRP STATIC type_qualifier_list assignment_expression RSQRP		   {   }
		| direct_declarator LSQRP STATIC assignment_expression RSQRP		                         {   }
		| direct_declarator LSQRP type_qualifier_list STATIC assignment_expression RSQRP          {   }
		| direct_declarator LSQRP type_qualifier_list MUL RSQRP                                {   }
		| direct_declarator LSQRP MUL RSQRP  {   }
		| direct_declarator LPAREN changetable parameter_type_list RPAREN
		{
			ST->name = $1->name;            // Set the name of the symbol table
			updateNextInstr();
			if($1->type->type != "void") 	 // Check if the function has a return type
			{
				symbolEntry *s = ST->lookup("return");   // Look up for the return type symbol	
				s->update($1->type);
				updateNextInstr();
			}
			$1->nested = ST;       
			updateNextInstr();	
			ST->parent = globalST;           // Set the global symbol table as the parent
			updateNextInstr();
			changeTable(globalST);           // Return to the global symbol table
			updateNextInstr();
			currSymbolPtr = $$;
			updateNextInstr();
		}
		| direct_declarator LPAREN changetable RPAREN
		{    
			ST->name = $1->name;            // Set the name of the symbol table
			updateNextInstr();
			if($1->type->type != "void")    // Check if the function has a return type
			{
				symbolEntry *s = ST->lookup("return");   // Look up for the return type symbol	
				s->update($1->type);
				updateNextInstr();		
			}
			$1->nested = ST;
			updateNextInstr();
			ST->parent = globalST;          // Set the global symbol table as the parent
			updateNextInstr();
			changeTable(globalST);          // Return to the global symbol table
			updateNextInstr();
			currSymbolPtr = $$;
			updateNextInstr();
		}
		| direct_declarator LPAREN identifier_list RPAREN
		{   }
		;

changetable
		: %empty 
		{ 	
			// Switches to the function's symbol table
			if(currSymbolPtr->nested == NULL) 
			{
				changeTable(new symboltable(""));  	// If the function symbol table doesn’t exist, create it
				updateNextInstr();
			}
			else 
			{
				changeTable(currSymbolPtr->nested); // If the function symbol table exists, switch to it
				updateNextInstr();
				emit("label", ST->name);			// Label the function scope in the symbol table
				updateNextInstr();
			}
		}
		;
		
pointer 
		: MUL type_qualifier_list_opt
		{ 
			$$ = new symboltype("ptr");				// Create a pointer type symbol
			updateNextInstr(); 
		}        
		| MUL type_qualifier_list_opt pointer
		{ 
			$$ = new symboltype("ptr", $3);         // Create a pointer type symbol with nested pointer type
			updateNextInstr();
		}
		;

type_qualifier_list 
		: type_qualifier  						{   }
		| type_qualifier_list type_qualifier 	{	}
		;


type_qualifier_list_opt 
		: type_qualifier_list  {	}
		| %empty			   {	}
		;


parameter_type_list 
		: parameter_list 			 {	 }
		| parameter_list COMMA DOTS  {	 }
		;


parameter_list 
		: parameter_declaration							{	}
		| parameter_list COMMA parameter_declaration	{	}
		;


parameter_declaration 
		: declaration_specifiers declarator  	{	}
		| declaration_specifiers 				{	}
		;


identifier_list 
		: IDENTIFIER 						 {    }
		| identifier_list COMMA IDENTIFIER   {	  }
		;


type_name 
		: specifier_qualifier_list {   }
		;


initializer 
		: assignment_expression
		{
			$$ = $1->location;    
		}
		| LFPAREN initializer_list RFPAREN        {  }
		| LFPAREN initializer_list COMMA RFPAREN  {  }
		;


initializer_list 
		: designation_opt initializer 						  {  }
		| initializer_list COMMA designation_opt initializer  {  }
		;


designation 
		: designator_list EQT {   }
		;


designation_opt 
		: designation 	{	}
		| %empty		{	}
		;


designator_list 
		: designator                 {   }
		| designator_list designator {   }
		;


designator 
		: LSQRP constant_expression RSQRP  {   }
		| DOT IDENTIFIER                                                {   }
		;


//*****----- 3.STATEMENTS ---******

statement 
		: labeled_statement  {    }
		| compound_statement
		{	
			$$ = $1;  					// Assign the value from compound_statement to the statement
		}
		| expression_statement
		{ 
			$$ = new Statement();       // Initialize a new Statement object, inheriting nextList
			$$->nextList = $1->nextList; 
		}
		| selection_statement
		{
			$$ = $1;  					// Assign the value from selection_statement to the statement
		}
		| iteration_statement
		{
			$$ = $1;  					// Assign the value from iteration_statement to the statement
		}
		| jump_statement
		{
			$$ = $1;  					// Assign the value from jump_statement to the statement   
		}
		;


labeled_statement 
		: IDENTIFIER COLON statement 				{	}
		| CASE constant_expression COLON statement  {	}
		| DEFAULT COLON statement 					{	}
		;


compound_statement 
		: LFPAREN block_item_list_opt RFPAREN  
		{
			$$ = $2;  					// Assign block_item_list_opt to the compound statement
		}
		;


block_item_list 
		: block_item
		{
			$$ = $1;  					// Assign the value from block_item to block_item_list
		}
		| block_item_list M block_item
		{
			$$ = $3;  					// Assign the value from the latest block_item to block_item_list
			backpatch($1->nextList, $2);	// Link the nextList of previous block_item to the current block_item via M
		}
		;


block_item 
		: declaration
		{
			$$ = new Statement();     	// Create a new Statement object for the declaration
		}
		| statement
		{
			$$ = $1;  					// Assign the value from statement to block_item
		}
		;


block_item_list_opt 
		: block_item_list  
		{ 
			$$ = $1;  					// Assign the value from block_item_list to block_item_list_opt
		}
		| %empty           
		{  
			$$ = new Statement();       // Initialize a new empty Statement object
		}
		;


expression_statement 
		: expression_opt SEMI_COL    {   }
		;


expression_opt 
		: expression
		{
			$$ = $1;   					// Assign the value from expression to expression_opt
		}
		| %empty
		{
			$$ = new Expression();		// Initialize a new empty Expression object
 		}
		;


selection_statement 
		: IF LPAREN expression N RPAREN M statement N %prec "LOWER_THAN_ELSE"
		{
			backpatch($4->nextList, nextinstr());  // Link nextList of N to the next instruction
			updateNextInstr();
			convertInt2Bool($3);        		 	// Convert expression to a boolean
			updateNextInstr();
			$$ = new Statement();        		 	// Initialize a new Statement object
			updateNextInstr();
			backpatch($3->trueList, $6);           // If expression is true, proceed to the statement
			updateNextInstr();
			list<int> temp = merge($3->falseList, $7->nextList);   
			// Merge falseList of the expression with nextList of the statement and second N
			updateNextInstr();
			$$->nextList = merge($8->nextList, temp);
			updateNextInstr();
		}
		| IF LPAREN expression N RPAREN M statement N ELSE M statement
		{
			backpatch($4->nextList, nextinstr());   // Link nextList of N to the next instruction
			updateNextInstr();
			convertInt2Bool($3);        		   // Convert expression to a boolean
			updateNextInstr();
			$$ = new Statement();        		   // Initialize a new Statement object
			updateNextInstr();
			backpatch($3->trueList, $6);           // If expression is true, go to M1; otherwise, go to M2
			updateNextInstr();
			backpatch($3->falseList, $10);
			updateNextInstr();
			list<int> temp = merge($7->nextList, $8->nextList);       
			// Merge the nextLists of the statement and the second N
			updateNextInstr();
			$$->nextList = merge($11->nextList, temp);	
			updateNextInstr();	
		}
		| SWITCH LPAREN expression RPAREN statement {   }
		;


iteration_statement 
		: WHILE M LPAREN expression RPAREN M statement  
		{
			$$ = new Statement();              // Initialize a new Statement object for the loop
			updateNextInstr();
			convertInt2Bool($4);               // Convert the integer result of the expression to a boolean
			updateNextInstr();
			backpatch($7->nextList, $2);       // Link the end of the statement back to re-evaluate the expression (M1)
			updateNextInstr();
			backpatch($4->trueList, $6);       // If the expression is true, proceed to the statement (M2)
			updateNextInstr();
			$$->nextList = $4->falseList;      // If the expression is false, exit the loop
			updateNextInstr();
			// Insert a 'goto' to avoid fallthrough after the loop
			string str = convertInt2String($2);
			updateNextInstr();
			emit("goto", str);                 // Emit 'goto' statement with label
			updateNextInstr();	
		}
		| DO M statement M WHILE LPAREN expression RPAREN SEMI_COL
		{
			$$ = new Statement();              // Initialize a new Statement object for the loop
			updateNextInstr();
			convertInt2Bool($7);               // Convert the integer result of the expression to a boolean
			updateNextInstr();
			backpatch($7->trueList, $2);       // If expression is true, repeat the statement
			updateNextInstr();
			backpatch($3->nextList, $4);       // Link statement end back to expression check
			updateNextInstr();
			$$->nextList = $7->falseList;      // Exit if the expression evaluates to false
			updateNextInstr();	
		}
		| FOR LPAREN expression_statement M expression_statement RPAREN M statement
		{
			$$ = new Statement();              // Initialize a new Statement object for the loop
			updateNextInstr();
			convertInt2Bool($5);               // Convert integer result of the expression to a boolean
			updateNextInstr();
			backpatch($5->trueList, $7);       // If the expression is true, proceed to M2
			updateNextInstr();
			backpatch($8->nextList, $4);       // After statement, return to M1 to re-evaluate
			updateNextInstr();
			string str = convertInt2String($4);
			updateNextInstr();
			emit("goto", str);                 // Insert 'goto' to prevent fallthrough
			updateNextInstr();
			$$->nextList = $5->falseList;      // Exit if expression evaluates to false
			updateNextInstr();
		}
		| FOR LPAREN expression_statement M expression_statement M expression N RPAREN M statement
		{
			$$ = new Statement();              // Initialize a new Statement object for the loop
			updateNextInstr();
			convertInt2Bool($5);               // Convert integer result of the expression to a boolean
			updateNextInstr();
			backpatch($5->trueList, $10);      // If the expression is true, proceed to M2
			updateNextInstr();
			backpatch($8->nextList, $4);       // After N, return to M1 for re-evaluation
			updateNextInstr();
			backpatch($11->nextList, $6);      // Link end of statement back to expression check
			updateNextInstr();
			string str = convertInt2String($6);
			updateNextInstr();
			emit("goto", str);                 // Insert 'goto' to prevent fallthrough
			updateNextInstr();
			$$->nextList = $5->falseList;      // Exit if expression evaluates to false
			updateNextInstr();	
		}
		;


jump_statement 
		: GOTO IDENTIFIER SEMI_COL
		{
			$$ = new Statement();    //create a new Statement object   		  
		}
		| CONTINUE SEMI_COL
		{
			$$ = new Statement();             
		}
		| BREAK SEMI_COL
		{
			$$ = new Statement();      		  
		}
		| RETURN expression SEMI_COL
		{
			$$ = new Statement();     		  
			updateNextInstr();
			  
			emit("return",$2->location->name);
			updateNextInstr();
		}
		| RETURN SEMI_COL
		{
			$$ = new Statement();     		  
			updateNextInstr();
			emit("return","");    //emit return             
			updateNextInstr();
		}
		;


//*****---- 4.External Definations ****----

translation_unit 
		: external_declaration                   {   }
		| translation_unit external_declaration  {   }
		;


external_declaration
		: function_definition  { }         // External declaration can either be a function or a regular declaration
		| declaration          { }
		;


function_definition
		: declaration_specifiers declarator declaration_list_opt changetable compound_statement
		{
			updateNextInstr();
			ST->parent = globalST;          // Directing parent pointer to the global symbol table
			updateNextInstr();
			changeTable(globalST);          // Changing the table to the global symbol table once function ends
			updateNextInstr();
		}
		;


declaration_list
		: declaration                   { }  // Declaration list consists of multiple declarations
        | declaration_list declaration  { }
		;


declaration_list_opt
		: declaration_list  { }              // Optional declaration list, can be empty
		| %empty            { }
		;

M 		: %empty 
		{
			// Backpatching: Stores the index of the next quad (intermediate code) to be generated
			// Used in control statements for managing jumps and other control flows
			$$ = nextinstr();
		}   
		;

N 		: %empty
		{
			// Backpatching: Inserts a 'goto' and stores the index of the next 'goto' statement
			// Ensures no fall-through in control structures like if-else or loops
			$$ = new Statement();            // Initializing new Statement object to store control flow
			$$->nextList = makelist(nextinstr());
			emit("goto", "");
		}
		;


%%

// Called when an error is encountered, outputs the error message
void yyerror(string str) {  
	cout << str << endl;
}
